{"version":3,"sources":["cortex/cortex.ts"],"names":[],"mappings":"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","file":"cortex.js","sourcesContent":["import {DAP} from \"../dap/dap\";\n\nimport {Debug} from \"../debug/debug\";\nimport {Memory} from \"../memory/memory\";\nimport {PreparedMemoryCommand} from \"../memory/prepared\";\nimport {assert} from \"../util\";\n\nimport {\n    CoreState,\n    CoreType,\n    CortexReg,\n    CortexSpecialReg,\n    CPUID_ARCHITECTURE_MASK,\n    CPUID_ARCHITECTURE_POS,\n    CPUID_IMPLEMENTER_MASK,\n    CPUID_IMPLEMENTER_POS,\n    CPUID_PARTNO_MASK,\n    CPUID_PARTNO_POS,\n    CPUIDImplementer,\n    DEFAULT_RUNCODE_TIMEOUT,\n    ISA,\n} from \"./constants\";\nimport {PreparedCortexMCommand} from \"./prepared\";\n\n/**\n * # Cortex M\n *\n * Manages access to a CPU core, and its associated memory and debug functionality.\n *\n * > **NOTE:** all of the methods that involve interaction with the CPU core\n * > are asynchronous, so must be `await`ed, or explicitly handled as a Promise.\n *\n * ## Usage\n *\n * First, let's create an instance of `CortexM`, using an associated _Debug Access\n * Port_ (DAP) instance that we created earlier.\n *\n * ```typescript\n * const core = new CortexM(dap);\n * ```\n *\n * Now, we can halt and resume the core just like this:\n *\n * > **NOTE:** If you're not using ES2017, you can replace the use of `async` and\n * > `await` with direct use of Promises. These examples also need to be run within\n * > an `async` function for `async` to be used.\n *\n * ```typescript\n * await core.halt();\n * await core.resume();\n * ```\n *\n * Resetting the core is just as easy:\n *\n * ```typescript\n * await core.reset();\n * ```\n *\n * You can even halt immediately after reset:\n *\n * ```typescript\n * await core.reset(true);\n * ```\n *\n * We can also read and write 32-bit values to/from core registers:\n *\n * ```typescript\n * const sp = await core.readCoreRegister(CortexReg.SP);\n *\n * await core.writeCoreRegister(CortexReg.R0, 0x1000);\n * await core.writeCoreRegister(CortexReg.PC, 0x1234);\n * ```\n *\n * ### See also\n *\n * For details on debugging and memory features, see the documentation for\n * `Debug` and `Memory`.\n */\nexport class CortexM {\n    /**\n     * Read and write to on-chip memory associated with this CPU core.\n     */\n    public readonly memory: Memory;\n\n    /**\n     * Control the CPU's debugging features.\n     */\n    public readonly debug: Debug;\n\n    /**\n     * Underlying Debug Access Port (DAP).\n     */\n    private dev: DAP;\n\n    constructor(device: DAP) {\n        this.dev = device;\n        this.memory = new Memory(device);\n        this.debug = new Debug(this);\n    }\n\n    /**\n     * Initialise the debug access port on the device, and read the device type.\n     */\n    public async init() {\n        await this.dev.init();\n\n        // FIXME: don't run this if security is enabled on the K64F\n        await this.debug.init();\n        await this.readCoreType();\n    }\n\n    /**\n     * Read the current state of the CPU.\n     *\n     * @returns A member of the `CoreState` enum corresponding to the current status of the CPU.\n     */\n    public async getState() {\n        const dhcsr = await this.memory.read32(CortexSpecialReg.DHCSR);\n\n        if (dhcsr & CortexSpecialReg.S_RESET_ST) {\n            const newDHCSR = await this.memory.read32(CortexSpecialReg.DHCSR);\n\n            if (newDHCSR & CortexSpecialReg.S_RESET_ST && !(newDHCSR & CortexSpecialReg.S_RETIRE_ST)) {\n                return CoreState.TARGET_RESET;\n            }\n        }\n\n        if (dhcsr & CortexSpecialReg.S_LOCKUP) {\n            return CoreState.TARGET_LOCKUP;\n        } else if (dhcsr & CortexSpecialReg.S_SLEEP) {\n            return CoreState.TARGET_SLEEPING;\n        } else if (dhcsr & CortexSpecialReg.S_HALT) {\n            return CoreState.TARGET_HALTED;\n        } else {\n            return CoreState.TARGET_RUNNING;\n        }\n    }\n\n    /**\n     * Read the CPUID register from the CPU, and interpret its meaning in terms of implementer,\n     * architecture and core type.\n     */\n    public async readCoreType(): Promise<[CPUIDImplementer, ISA, CoreType]> {\n        const cpuid = await this.memory.read32(CortexSpecialReg.CPUID);\n\n        const implementer = ((cpuid & CPUID_IMPLEMENTER_MASK) >> CPUID_IMPLEMENTER_POS) as CPUIDImplementer;\n        const arch = ((cpuid & CPUID_ARCHITECTURE_MASK) >> CPUID_ARCHITECTURE_POS) as ISA;\n        const coreType = ((cpuid & CPUID_PARTNO_MASK) >> CPUID_PARTNO_POS) as CoreType;\n        return [implementer, arch, coreType];\n    }\n\n    public prepareCommand(): PreparedCortexMCommand {\n        return new PreparedCortexMCommand(this.dev);\n    }\n\n    /**\n     * Read a core register from the CPU (e.g. r0...r15, pc, sp, lr, s0...)\n     *\n     * @param no Member of the `CortexReg` enum - an ARM Cortex CPU general-purpose register.\n     */\n    public async readCoreRegister(no: CortexReg) {\n        await this.memory.write32(CortexSpecialReg.DCRSR, no);\n        const v = await this.memory.read32(CortexSpecialReg.DHCSR);\n        assert(v & CortexSpecialReg.S_REGRDY);\n        return await this.memory.read32(CortexSpecialReg.DCRDR);\n    }\n\n    /**\n     * Write a 32-bit word to the specified CPU general-purpose register.\n     *\n     * @param no Member of the `CortexReg` enum - an ARM Cortex CPU general-purpose register.\n     * @param val Value to be written.\n     */\n    public async writeCoreRegister(no: CortexReg, val: number) {\n        const prep = new PreparedMemoryCommand(this.dev);\n\n        prep.write32(CortexSpecialReg.DCRDR, val);\n        prep.write32(CortexSpecialReg.DCRSR, no | CortexSpecialReg.DCRSR_REGWnR);\n        prep.read32(CortexSpecialReg.DHCSR);\n        const v = (await prep.go())[0];\n\n        assert(v & CortexSpecialReg.S_REGRDY);\n    }\n\n    /**\n     * Halt the CPU core.\n     */\n    public async halt() {\n        return this.memory.write32(\n            CortexSpecialReg.DHCSR,\n            CortexSpecialReg.DBGKEY | CortexSpecialReg.C_DEBUGEN | CortexSpecialReg.C_HALT,\n        );\n    }\n\n    /**\n     * Resume the CPU core.\n     */\n    public async resume() {\n        if (await this.isHalted()) {\n            await this.memory.write32(\n                CortexSpecialReg.DFSR,\n                CortexSpecialReg.DFSR_DWTTRAP | CortexSpecialReg.DFSR_BKPT | CortexSpecialReg.DFSR_HALTED,\n            );\n            await this.debug.enable();\n        }\n    }\n\n    /**\n     * Find out whether the CPU is halted.\n     */\n    public async isHalted() {\n        const s = await this.status();\n        return s.isHalted;\n    }\n\n    /**\n     * Read the current status of the CPU.\n     *\n     * @returns Object containing the contents of the `DHCSR` register, the `DFSR` register, and a boolean value\n     * stating the current halted state of the CPU.\n     */\n    public async status() {\n        const prep = new PreparedMemoryCommand(this.dev);\n\n        prep.read32(CortexSpecialReg.DHCSR);\n        prep.read32(CortexSpecialReg.DFSR);\n\n        const results = await prep.go();\n\n        const dhcsr = results[0];\n        const dfsr = results[1];\n\n        return {\n            dfsr,\n            dhscr: dhcsr,\n            isHalted: !!(dhcsr & CortexSpecialReg.S_HALT),\n        };\n    }\n\n    /**\n     * Reset the CPU core. This currently does a software reset - it is also technically possible to perform a 'hard'\n     * reset using the reset pin from the debugger.\n     */\n    public async reset(halt = false) {\n        if (halt) {\n            await this.halt();\n\n            // VC_CORERESET causes the core to halt on reset.\n            const demcr = await this.memory.read32(CortexSpecialReg.DEMCR);\n            await this.memory.write32(CortexSpecialReg.DEMCR, demcr | CortexSpecialReg.DEMCR_VC_CORERESET);\n\n            await this.softwareReset();\n            await this.waitForHalt();\n\n            // Unset the VC_CORERESET bit\n            await this.memory.write32(CortexSpecialReg.DEMCR, demcr);\n        } else {\n            await this.softwareReset();\n        }\n    }\n\n    /**\n     * Run specified machine code natively on the device. Assumes usual C calling conventions\n     * - returns the value of r0 once the program has terminated. The program _must_ terminate\n     * in order for this function to return. This can be achieved by placing a `bkpt`\n     * instruction at the end of the function.\n     *\n     * @param code array containing the machine code (32-bit words).\n     * @param address memory address at which to place the code.\n     * @param pc initial value of the program counter.\n     * @param lr initial value of the link register.\n     * @param sp initial value of the stack pointer.\n     * @param upload should we upload the code before running it.\n     * @param args set registers r0...rn before running code\n     *\n     * @returns A promise for the value of r0 on completion of the function call.\n     */\n    public async runCode(\n        code: Uint32Array,\n        address: number,\n        pc: number,\n        lr: number,\n        sp: number,\n        upload: boolean,\n        ...args: number[]) {\n\n        // await this.halt();\n\n        const cmd = this.prepareCommand();\n\n        cmd.halt();\n\n        // Point the program counter to the start of the program\n        cmd.writeCoreRegister(CortexReg.PC, pc);\n        cmd.writeCoreRegister(CortexReg.LR, lr);\n        cmd.writeCoreRegister(CortexReg.SP, sp);\n\n        for (let i = 0; i < args.length; i++) {\n            cmd.writeCoreRegister(i, args[i]);\n        }\n\n        await cmd.go();\n\n        // Write the program to memory at the specified address\n        if (upload) {\n            await this.memory.writeBlock(address, code);\n        }\n\n        // Run the program and wait for halt\n        await this.resume();\n        await this.waitForHalt(DEFAULT_RUNCODE_TIMEOUT); // timeout after 10s\n\n        return await this.readCoreRegister(CortexReg.R0);\n    }\n\n    /**\n     * Spin until the chip has halted.\n     */\n    public async waitForHalt(timeout = 0) {\n        return new Promise<void>(async (resolve, reject) => {\n            let running = true;\n\n            if (timeout > 0) {\n                setTimeout(() => {\n                    reject(\"waitForHalt timed out.\");\n                    running = false;\n                }, timeout);\n            }\n\n            while (running && !(await this.isHalted())) {\n                /* empty */\n            }\n\n            if (running) {\n                resolve();\n            }\n        });\n    }\n\n    private async softwareReset() {\n        await this.memory.write32(\n            CortexSpecialReg.NVIC_AIRCR,\n            CortexSpecialReg.NVIC_AIRCR_VECTKEY | CortexSpecialReg.NVIC_AIRCR_SYSRESETREQ,\n        );\n\n        // wait for the system to come out of reset\n        let dhcsr = await this.memory.read32(CortexSpecialReg.DHCSR);\n\n        while ((dhcsr & CortexSpecialReg.S_RESET_ST) !== 0) {\n            dhcsr = await this.memory.read32(CortexSpecialReg.DHCSR);\n        }\n    }\n}\n"],"sourceRoot":"../../src"}