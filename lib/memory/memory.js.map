{"version":3,"sources":["memory/memory.ts"],"names":[],"mappings":"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","file":"memory.js","sourcesContent":["import {DAP} from \"../dap/dap\";\n\nimport {ApReg, Csw,  DapVal} from \"../dap/constants\";\nimport {apReg, assert, bufferConcat, delay} from \"../util\";\n\nimport {PreparedMemoryCommand} from \"./prepared\";\n\n/**\n * # Memory Interface\n *\n * Controls access to the target's memory.\n *\n * ## Usage\n *\n * Using an instance of `CortexM`, as described before, we can simply read and\n * write numbers to memory as follows:\n *\n * ```typescript\n * const mem = core.memory;\n *\n * // NOTE: the address parameter must be word (4-byte) aligned.\n * await mem.write32(0x200000, 12345);\n * const val = await mem.read32(0x200000);\n *\n * // val === 12345\n *\n * // NOTE: the address parameter must be half-word (2-byte) aligned\n * await mem.write16(0x2000002, 65534);\n * const val16 = await mem.read16(0x2000002);\n *\n * // val16 === 65534\n * ```\n *\n * To write a larger block of memory, we can use `readBlock` and `writeBlock`. Again,\n * these blocks must be written to word-aligned addresses in memory.\n *\n * ```typescript\n * const data = new Uint32Array([0x1234, 0x5678, 0x9ABC, 0xDEF0]);\n * await mem.writeBlock(0x200000, data);\n *\n * const readData = await mem.readBlock(0x200000, data.length, 0x100);\n * ```\n *\n * ## See also\n *\n * `PreparedMemoryCommand` provides an equivalent API with better performance (in some\n * cases) by enabling batched memory operations.\n */\nexport class Memory {\n    private dev: DAP;\n\n    constructor(dev: DAP) {\n        this.dev = dev;\n    }\n\n    /**\n     * Write a 32-bit word to the specified (word-aligned) memory address.\n     *\n     * @param addr Memory address to write to\n     * @param data Data to write (values above 2**32 will be truncated)\n     */\n    public async write32(addr: number, data: number) {\n        const prep = this.dev.prepareCommand();\n        prep.writeAp(ApReg.CSW, Csw.CSW_VALUE | Csw.CSW_SIZE32);\n        prep.writeAp(ApReg.TAR, addr);\n        prep.writeAp(ApReg.DRW, data);\n\n        await prep.go();\n    }\n\n    /**\n     * Write a 16-bit word to the specified (half word-aligned) memory address.\n     *\n     * @param addr Memory address to write to\n     * @param data Data to write (values above 2**16 will be truncated)\n     */\n    public async write16(addr: number, data: number) {\n        data = data << ((addr & 0x02) << 3);\n\n        const prep = this.dev.prepareCommand();\n        prep.writeAp(ApReg.CSW, Csw.CSW_VALUE | Csw.CSW_SIZE16);\n        prep.writeAp(ApReg.TAR, addr);\n        prep.writeAp(ApReg.DRW, data);\n\n        await prep.go();\n    }\n\n    /**\n     * Read a 32-bit word from the specified (word-aligned) memory address.\n     *\n     * @param addr Memory address to read from.\n     */\n    public async read32(addr: number): Promise<number> {\n        const prep = this.dev.prepareCommand();\n\n        prep.writeAp(ApReg.CSW, Csw.CSW_VALUE | Csw.CSW_SIZE32);\n        prep.writeAp(ApReg.TAR, addr);\n        prep.readAp(ApReg.DRW);\n\n        try {\n            return (await prep.go())[0];\n        } catch (e) {\n            // transfer wait, try again.\n            await delay(100);\n            return await this.read32(addr);\n        }\n    }\n\n    /**\n     * Read a 16-bit word from the specified (half word-aligned) memory address.\n     *\n     * @param addr Memory address to read from.\n     */\n    public async read16(addr: number): Promise<number> {\n        const prep = this.dev.prepareCommand();\n\n        prep.writeAp(ApReg.CSW, Csw.CSW_VALUE | Csw.CSW_SIZE16);\n        prep.writeAp(ApReg.TAR, addr);\n        prep.readAp(ApReg.DRW);\n\n        let val;\n\n        try {\n            val = (await prep.go())[0];\n        } catch (e) {\n            // transfer wait, try again.\n            await delay(100);\n            val = await this.read16(addr);\n        }\n\n        val = (val >> ((addr & 0x02) << 3) & 0xffff);\n        return val;\n    }\n\n    /**\n     * Reads a block of memory from the specified memory address.\n     *\n     * @param addr Address to read from\n     * @param words Number of words to read\n     * @param pageSize Memory page size\n     */\n    public async readBlock(addr: number, words: number, pageSize: number) {\n        const funs = [async () => Promise.resolve()];\n        const bufs: Uint8Array[] = [];\n        const end = addr + words * 4;\n        let ptr = addr;\n\n        while (ptr < end) {\n            let nextptr = ptr + pageSize;\n            if (ptr === addr) {\n                nextptr &= ~(pageSize - 1);\n            }\n\n            const len = Math.min(nextptr - ptr, end - ptr);\n            const ptr0 = ptr;\n            assert((len & 3) === 0);\n            funs.push(async () => {\n                bufs.push(await this.readBlockCore(ptr0, len >> 2));\n            });\n\n            ptr = nextptr;\n        }\n\n        for (const f of funs) {\n            await f();\n        }\n\n        const result = await bufferConcat(bufs);\n        return result.subarray(0, words * 4);\n    }\n\n    /**\n     * Write a block of memory to the specified memory address.\n     *\n     * @param addr Memory address to write to.\n     * @param words Array of 32-bit words to write to memory.\n     */\n    public async writeBlock(addr: number, words: Uint32Array) {\n        if (words.length === 0) {\n            return;\n        }\n\n        return this.writeBlockCore(addr, words);\n    }\n\n    public prepareCommand() {\n        return new PreparedMemoryCommand(this.dev);\n    }\n\n    private async readBlockCore(addr: number, words: number) {\n        const prep = this.dev.prepareCommand();\n        prep.writeAp(ApReg.CSW, Csw.CSW_VALUE | Csw.CSW_SIZE32);\n        prep.writeAp(ApReg.TAR, addr);\n        await prep.go();\n\n        let lastSize = words % 15;\n        if (lastSize === 0) {\n            lastSize = 15;\n        }\n\n        const blocks: Uint8Array[] = [];\n\n        for (let i = 0; i < Math.ceil(words / 15); i++) {\n            const b = await this.dev.readRegRepeat(\n                apReg(ApReg.DRW, DapVal.READ),\n                i === blocks.length - 1 ? lastSize : 15,\n            );\n            blocks.push(b);\n        }\n\n        return bufferConcat(blocks);\n    }\n\n    private async writeBlockCore(addr: number, words: Uint32Array): Promise<void> {\n        try {\n            const blSz = 14;\n            const reg = apReg(ApReg.DRW, DapVal.WRITE);\n\n            const prep = this.dev.prepareCommand();\n            prep.writeAp(ApReg.CSW, Csw.CSW_VALUE | Csw.CSW_SIZE32);\n            prep.writeAp(ApReg.TAR, addr);\n\n            for (let i = 0; i < Math.ceil(words.length / blSz); i++) {\n                prep.writeRegRepeat(reg, words.subarray(i * blSz, i * blSz + blSz));\n            }\n\n            await prep.go();\n        } catch (e) {\n            if (e.dapWait) {\n                await delay(100);\n                return await this.writeBlockCore(addr, words);\n            } else {\n                throw e;\n            }\n        }\n    }\n}\n"],"sourceRoot":"../../src"}