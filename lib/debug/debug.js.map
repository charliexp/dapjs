{"version":3,"sources":["debug/debug.ts"],"names":[],"mappings":"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","file":"debug.js","sourcesContent":["import {CortexSpecialReg} from \"../cortex/constants\";\nimport {CortexM} from \"../cortex/cortex\";\n\nimport {DisabledBreakpoint, HWBreakpoint, IBreakpoint, SWBreakpoint} from \"./breakpoint\";\n\n/**\n * # Debug Interface\n *\n * Keeps track of breakpoints set on the target, as well as deciding whether to\n * use a hardware breakpoint or a software breakpoint.\n *\n * ## Usage\n *\n * ```typescript\n * const dbg = core.debug;\n *\n * await dbg.setBreakpoint(0x123456);\n *\n * // resume the core and wait for the breakpoint\n * await core.resume();\n * await core.waitForHalt();\n *\n * // step forward one instruction\n * await dbg.step();\n *\n * // remove the breakpoint\n * await dbg.deleteBreakpoint(0x123456);\n * ```\n */\nexport class Debug {\n    private core: CortexM;\n\n    // if the breakpoint is disabled, call it a number\n    private breakpoints: Map<number, IBreakpoint | DisabledBreakpoint>;\n    private availableHWBreakpoints: number[];\n    // private totalHWBreakpoints: number;\n\n    private enabled: boolean;\n\n    constructor(core: CortexM) {\n        this.core = core;\n        this.enabled = false;\n        this.availableHWBreakpoints = [];\n        this.breakpoints = new Map<number, IBreakpoint | DisabledBreakpoint>();\n    }\n\n    public async init() {\n        return this.setupFpb();\n    }\n\n    /**\n     * Enable debugging on the target CPU\n     */\n    public async enable() {\n        await this.core.memory.write32(CortexSpecialReg.DHCSR, CortexSpecialReg.DBGKEY | CortexSpecialReg.C_DEBUGEN);\n    }\n\n    /**\n     * Set breakpoints at specified memory addresses.\n     *\n     * @param addrs An array of memory addresses at which to set breakpoints.\n     */\n    public async setBreakpoint(addr: number) {\n        if (this.breakpoints.has(addr)) {\n            // we already have a breakpoint there.\n            const breakpoint = this.breakpoints.get(addr);\n            if (typeof breakpoint !== \"number\") {\n                // already enabled\n                // tslint:disable-next-line:no-console\n                console.warn(`Breakpoint at ${addr.toString(16)} already enabled.`);\n                return;\n            }\n        }\n\n        let bkpt: IBreakpoint;\n\n        // choose where best to place a breakpoint\n        if (addr < 0x20000000) {\n            // we can use a HWBreakpoint\n\n            if (this.availableHWBreakpoints.length > 0) {\n                if (!this.enabled) {\n                    await this.setFpbEnabled(true);\n                }\n\n                const regAddr = this.availableHWBreakpoints.pop();\n                bkpt = new HWBreakpoint(regAddr, this.core, addr);\n            } else {\n                bkpt = new SWBreakpoint(this.core, addr);\n            }\n        } else {\n            bkpt = new SWBreakpoint(this.core, addr);\n        }\n\n        await bkpt.set();\n        this.breakpoints.set(addr, bkpt);\n    }\n\n    public async deleteBreakpoint(addr: number) {\n        if (this.breakpoints.has(addr)) {\n            const bkpt = this.breakpoints.get(addr);\n            if (typeof bkpt !== \"number\") {\n                await bkpt.clear();\n\n                if (bkpt instanceof HWBreakpoint) {\n                    // return the register address to the pool\n                    this.availableHWBreakpoints.push(bkpt.regAddr);\n                }\n            }\n\n            this.breakpoints.delete(addr);\n        } else {\n            // tslint:disable-next-line:no-console\n            console.warn(`Breakpoint at ${addr.toString(16)} does not exist.`);\n        }\n    }\n\n    /**\n     * Step the processor forward by one instruction.\n     */\n    public async step() {\n        const dhcsr = await this.core.memory.read32(CortexSpecialReg.DHCSR);\n\n        if (!(dhcsr & (CortexSpecialReg.C_STEP | CortexSpecialReg.C_HALT))) {\n            // tslint:disable-next-line:no-console\n            console.error(\"Target is not halted.\");\n            return;\n        }\n\n        const interruptsMasked = (CortexSpecialReg.C_MASKINTS & dhcsr) !== 0;\n\n        if (!interruptsMasked) {\n            await this.core.memory.write32(\n                CortexSpecialReg.DHCSR,\n                CortexSpecialReg.DBGKEY |\n                CortexSpecialReg.C_DEBUGEN |\n                CortexSpecialReg.C_HALT |\n                CortexSpecialReg.C_MASKINTS,\n            );\n        }\n\n        await this.core.memory.write32(\n            CortexSpecialReg.DHCSR,\n            CortexSpecialReg.DBGKEY |\n            CortexSpecialReg.C_DEBUGEN |\n            CortexSpecialReg.C_MASKINTS |\n            CortexSpecialReg.C_STEP,\n        );\n\n        await this.core.waitForHalt();\n\n        await this.core.memory.write32(\n            CortexSpecialReg.DHCSR,\n            CortexSpecialReg.DBGKEY |\n            CortexSpecialReg.C_DEBUGEN |\n            CortexSpecialReg.C_HALT,\n        );\n    }\n\n    /**\n     * Set up (and disable) the Flash Patch & Breakpoint unit. It will be enabled when\n     * the first breakpoint is set.\n     *\n     * Also reads the number of available hardware breakpoints.\n     */\n    private async setupFpb() {\n        // setup FPB (breakpoint)\n        const fpcr = await this.core.memory.read32(CortexSpecialReg.FP_CTRL);\n        const nbCode = ((fpcr >> 8) & 0x70) | ((fpcr >> 4) & 0xf);\n        // const nbLit = (fpcr >> 7) & 0xf;\n\n        // this.totalHWBreakpoints = nbCode;\n\n        await this.setFpbEnabled(false);\n\n        for (let i = 0; i < nbCode; i++) {\n            this.availableHWBreakpoints.push(CortexSpecialReg.FP_COMP0 + (4 * i));\n            await this.core.memory.write32(CortexSpecialReg.FP_COMP0 + (i * 4), 0);\n        }\n    }\n\n    /**\n     * Enable or disable the Flash Patch and Breakpoint unit (FPB).\n     *\n     * @param enabled\n     */\n    private async setFpbEnabled(enabled = true) {\n        this.enabled = enabled;\n        await this.core.memory.write32(CortexSpecialReg.FP_CTRL, CortexSpecialReg.FP_CTRL_KEY | (enabled ? 1 : 0));\n    }\n}\n"],"sourceRoot":"../../src"}