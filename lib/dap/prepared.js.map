{"version":3,"sources":["dap/prepared.ts"],"names":[],"mappings":";;;;;;;;;;AAGA,kCAAwE;AAExE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAiCG;AACH;IASI,YAAoB,GAAa;QAAb,QAAG,GAAH,GAAG,CAAU;QAC7B,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACzB,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;QACzB,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;QACxB,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;IAC1B,CAAC;IAED;;;;;OAKG;IACI,QAAQ,CAAC,KAAU,EAAE,KAAa;QACrC,MAAM,OAAO,GAAG,iBAAU,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QAExC,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,MAAM,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;YACrD,sBAAsB;YACtB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YAC3B,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC3B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACxB,IAAI,CAAC,cAAc,EAAE,CAAC;QAC1B,CAAC;QAED,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACjD,eAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE,KAAK,CAAC,CAAC;QAEpD,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC;IAC9C,CAAC;IAED;;;OAGG;IACI,OAAO,CAAC,KAAU;QACrB,MAAM,OAAO,GAAG,iBAAU,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QAEzC,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,MAAM,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;YACrD,sBAAsB;YACtB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YAC3B,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC3B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACxB,IAAI,CAAC,cAAc,EAAE,CAAC;QAC1B,CAAC;QAED,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAEjD,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC;QAC1C,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC;IAC3C,CAAC;IAED;;;;;;;;;;;OAWG;IACI,cAAc,CAAC,KAAU,EAAE,IAAiB;QAC/C,+CAA+C;QAC/C,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;YACf,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;QAC9B,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;OAEG;IACU,EAAE;;YACX,MAAM,CAAC,GAAa,EAAE,CAAC;YAEvB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC5C,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACjC,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;gBAEnC,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,GAAG,CAAC,OAAO,uBAAsB,OAAO,CAAC,CAAC;gBAEpE,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;oBAC1C,CAAC,CAAC,IAAI,CAAC,mBAAY,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC5C,CAAC;YACL,CAAC;YAED,MAAM,CAAC,CAAC,CAAC;QACb,CAAC;KAAA;IAED;;;;;OAKG;IACI,OAAO,CAAC,IAAS,EAAE,IAAY;QAClC,EAAE,CAAC,CAAC,IAAI,mBAAe,CAAC,CAAC,CAAC;YACtB,EAAE,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACzB,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;YAC7B,CAAC;YAED,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACzB,CAAC;QAED,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACrC,CAAC;IAED;;;;;OAKG;IACI,OAAO,CAAC,IAAW,EAAE,IAAY;QACpC,IAAI,CAAC,OAAO,iBAAa,WAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAErC,EAAE,CAAC,CAAC,IAAI,gBAAc,CAAC,CAAC,CAAC;YACrB,EAAE,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;gBACpB,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;YAC7B,CAAC;YAED,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC;QACpB,CAAC;QAED,IAAI,CAAC,QAAQ,CAAC,YAAK,CAAC,IAAI,gBAAe,EAAE,IAAI,CAAC,CAAC;IACnD,CAAC;IAED;;;;OAIG;IACI,MAAM,CAAC,IAAS;QACnB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IAC9B,CAAC;IAED;;;;OAIG;IACI,MAAM,CAAC,IAAW;QACrB,IAAI,CAAC,OAAO,iBAAa,WAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACrC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,YAAK,CAAC,IAAI,eAAc,CAAC,CAAC;IAClD,CAAC;CACJ;AA3JD,gDA2JC","file":"prepared.js","sourcesContent":["import {ApReg, DapVal, Reg} from \"./constants\";\n\nimport {CMSISDAP, DapCmd} from \"../transport/cmsis_dap\";\nimport {addInt32, apReg, bank, readUInt32LE, regRequest} from \"../util\";\n\n/**\n * # Prepared DAP Command\n *\n * Batches together multiple Debug Access Port (DAP) commands into one (or more)\n * CMSIS-DAP Transfers that can be written together to improve link utilisation.\n *\n * > **NOTE:** this will not normally need to be used by applications or libraries\n * > depending on DAP.js.\n *\n * ## Architecture\n *\n * - `PreparedDapCommand` keeps a list of CMSIS-DAP `Transfer` commands.\n * - Every time an action is scheduled (writing to or reading from a DP or AP register),\n * we check to see if there is any remaining room in the current batch, starting a new\n * batch if none is available.\n * - When `go` is called, the batches are executed sequentially (so DAP commands are\n * executed in the order they were added).\n *\n * ### Reading Values\n *\n * Writing values to registers is relatively straight forward, however mixing register\n * reads and writes together requires us to keep track of how many commands in\n * each batch are read commands.\n *\n * Once data has successfully been read back from the target, the values read are assembled\n * into an array, and returned in the order they requested. This allows `PreparedDapCommand`s\n * to be used higher up the stack in places where multiple independent read operations take\n * place sequentially.\n *\n * ### Constructing CMSIS-DAP Commands\n *\n * We keep track of the number of commands in each batch, so that we can fill in the command\n * count field of the `DAP_Transfer`.\n */\nexport class PreparedDapCommand {\n    private commands: number[][];\n    private readCounts: number[];\n    private currentCommand: number;\n    private commandCounts: number[];\n\n    private dpSelect: number;\n    private csw: number;\n\n    constructor(private dap: CMSISDAP) {\n        this.commands = [[0, 1]];\n        this.commandCounts = [0];\n        this.currentCommand = 0;\n        this.readCounts = [0];\n    }\n\n    /**\n     * Schedule a value to be written to an AP or DP register.\n     *\n     * @param regId register ID to be written to\n     * @param value value to be written\n     */\n    public writeReg(regId: Reg, value: number) {\n        const request = regRequest(regId, true);\n\n        if (this.commands[this.currentCommand].length + 5 > 64) {\n            // start a new command\n            this.commands.push([0, 1]);\n            this.commandCounts.push(0);\n            this.readCounts.push(0);\n            this.currentCommand++;\n        }\n\n        this.commands[this.currentCommand].push(request);\n        addInt32(this.commands[this.currentCommand], value);\n\n        this.commandCounts[this.currentCommand]++;\n    }\n\n    /**\n     * Schedule a value to be read from an AP or DP register.\n     * @param regId register to read from\n     */\n    public readReg(regId: Reg) {\n        const request = regRequest(regId, false);\n\n        if (this.commands[this.currentCommand].length + 1 > 64) {\n            // start a new command\n            this.commands.push([0, 1]);\n            this.commandCounts.push(0);\n            this.readCounts.push(0);\n            this.currentCommand++;\n        }\n\n        this.commands[this.currentCommand].push(request);\n\n        this.commandCounts[this.currentCommand]++;\n        this.readCounts[this.currentCommand]++;\n    }\n\n    /**\n     * Schedule multiple values to be written to the same register.\n     *\n     * **TODO:** figure out dynamically whether it's better to use DAP_TransferBlock vs\n     * DAP_Transfer. We should be able to fill up the remaining space in a Transfer\n     * and then start a TransferBlock _if_ we can fit in _13 or more_ values into the\n     * TransferBlock. However, the gains from this are marginal unless we're using much\n     * larger packet sizes than 64 bytes.\n     *\n     * @param regId register to write to repeatedly\n     * @param data array of 32-bit values to be written\n     */\n    public writeRegRepeat(regId: Reg, data: Uint32Array) {\n        // fill up the rest of the command we have left\n        data.forEach(cmd => {\n            this.writeReg(regId, cmd);\n        });\n    }\n\n    /**\n     * Asynchronously execute the commands scheduled.\n     */\n    public async go(): Promise<number[]> {\n        const v: number[] = [];\n\n        for (let i = 0; i < this.commands.length; i++) {\n            const command = this.commands[i];\n            command[1] = this.commandCounts[i];\n\n            const result = await this.dap.cmdNums(DapCmd.DAP_TRANSFER, command);\n\n            for (let j = 0; j < this.readCounts[i]; j++) {\n                v.push(readUInt32LE(result, 3 + 4 * j));\n            }\n        }\n\n        return v;\n    }\n\n    /**\n     * Schedule a value to be written to a DP register\n     *\n     * @param addr Address to write to\n     * @param data Data to be written\n     */\n    public writeDp(addr: Reg, data: number) {\n        if (addr === Reg.SELECT) {\n            if (data === this.dpSelect) {\n                return Promise.resolve();\n            }\n\n            this.dpSelect = data;\n        }\n\n        return this.writeReg(addr, data);\n    }\n\n    /**\n     * Schedule a value to be written to an AP register\n     *\n     * @param addr Address to write to\n     * @param data Data to be written\n     */\n    public writeAp(addr: ApReg, data: number) {\n        this.writeDp(Reg.SELECT, bank(addr));\n\n        if (addr === ApReg.CSW) {\n            if (data === this.csw) {\n                return Promise.resolve();\n            }\n\n            this.csw = data;\n        }\n\n        this.writeReg(apReg(addr, DapVal.WRITE), data);\n    }\n\n    /**\n     * Schedule a DP register to read from\n     *\n     * @param addr Address to read from\n     */\n    public readDp(addr: Reg) {\n        return this.readReg(addr);\n    }\n\n    /**\n     * Schedule an AP register to read from\n     *\n     * @param addr Address to read from\n     */\n    public readAp(addr: ApReg) {\n        this.writeDp(Reg.SELECT, bank(addr));\n        return this.readReg(apReg(addr, DapVal.READ));\n    }\n}\n"],"sourceRoot":"../../src"}